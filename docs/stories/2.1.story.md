# Story 2.1: String Validation Keywords

## Status

**Approved**

## Story

**As a** developer,
**I want** the validator to enforce string constraints,
**so that** I can validate string length, patterns, and formats.

## Acceptance Criteria

1. `minLength` keyword validates string has at least N characters
2. `maxLength` keyword validates string has at most N characters
3. Combined `minLength` and `maxLength` work together correctly
4. `pattern` keyword validates string matches ECMAScript regex pattern
5. `format` keyword validates common formats: `date-time`, `date`, `time`, `email`, `uri`, `uuid`
6. Format validation is lenient (warns but doesn't fail) per JSON Schema spec, OR configurable
7. Error messages indicate which constraint failed and the actual vs expected values
8. Error object includes correct `keyword` (`minLength`, `maxLength`, `pattern`, `format`)
9. Unit tests cover each keyword with valid and invalid cases
10. Unit tests cover edge cases (empty string, unicode characters)

## Tasks / Subtasks

- [ ] **Task 1: Create JSONSchema.Keyword.String.cls** (AC: 1, 2, 3, 4, 5, 6, 7, 8)
  - [ ] Create file: `src/JSONSchema/Keyword/String.cls`
  - [ ] Add class header and documentation
  - [ ] Implement `ValidateMinLength(pData, pMinLength, pContext)` ClassMethod
  - [ ] Implement `ValidateMaxLength(pData, pMaxLength, pContext)` ClassMethod
  - [ ] Implement `ValidatePattern(pData, pPattern, pContext)` ClassMethod using `$Match()`
  - [ ] Implement `ValidateFormat(pData, pFormat, pContext)` ClassMethod
  - [ ] Add format validators: `ValidateDateTime()`, `ValidateDate()`, `ValidateTime()`, `ValidateEmail()`, `ValidateUri()`, `ValidateUuid()`
  - [ ] Use `$Length()` for string length calculations (handles Unicode correctly)
  - [ ] Ensure format validation is lenient (returns 1 but can log warnings)
  - [ ] Add comprehensive error messages showing actual vs expected values
  - [ ] Compile using MCP tool `compile_objectscript_class`

- [ ] **Task 2: Update Validator.cls to Call String Keywords** (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Update `ValidateNode()` method in Validator.cls
  - [ ] Add check for `minLength` keyword: `If pSchema.%IsDefined("minLength")`
  - [ ] Add check for `maxLength` keyword: `If pSchema.%IsDefined("maxLength")`
  - [ ] Add check for `pattern` keyword: `If pSchema.%IsDefined("pattern")`
  - [ ] Add check for `format` keyword: `If pSchema.%IsDefined("format")`
  - [ ] Call string keyword validators only if data is a string type
  - [ ] Compile Validator.cls using MCP tool

- [ ] **Task 3: Create Unit Tests for minLength and maxLength** (AC: 1, 2, 3, 9, 10)
  - [ ] Create or update test file based on Story 1.6 organization (likely `TestStringKeywords.cls`)
  - [ ] **2.1-UNIT-001 (P0)**: `TestMinLengthValid()` - String with length >= minLength passes
  - [ ] **2.1-UNIT-002 (P0)**: `TestMinLengthInvalid()` - String with length < minLength fails
  - [ ] **2.1-UNIT-003 (P1)**: `TestMinLengthBoundary()` - String with length exactly equal to minLength passes
  - [ ] **2.1-UNIT-004 (P0)**: `TestMaxLengthValid()` - String with length <= maxLength passes
  - [ ] **2.1-UNIT-005 (P0)**: `TestMaxLengthInvalid()` - String with length > maxLength fails
  - [ ] **2.1-UNIT-006 (P1)**: `TestMaxLengthBoundary()` - String with length exactly equal to maxLength passes
  - [ ] **2.1-UNIT-007 (P0)**: `TestMinMaxLengthCombined()` - Both constraints work together
  - [ ] **2.1-UNIT-008 (P1)**: `TestMinLengthUnicode()` - Unicode strings counted by character, not bytes
  - [ ] **2.1-UNIT-009 (P2)**: `TestMinLengthEmptyString()` - Empty string fails minLength > 0
  - [ ] **2.1-UNIT-010 (P1)**: `TestMaxLengthEmptyString()` - Empty string passes maxLength >= 0

- [ ] **Task 4: Create Unit Tests for pattern** (AC: 4, 7, 8, 9, 10)
  - [ ] **2.1-UNIT-011 (P0)**: `TestPatternValid()` - String matching pattern passes
  - [ ] **2.1-UNIT-012 (P0)**: `TestPatternInvalid()` - String not matching pattern fails
  - [ ] **2.1-UNIT-013 (P1)**: `TestPatternSimple()` - Simple patterns like "^[0-9]+$" for digits
  - [ ] **2.1-UNIT-014 (P1)**: `TestPatternComplex()` - Complex regex patterns
  - [ ] **2.1-UNIT-015 (P1)**: `TestPatternUnicode()` - Pattern matching with Unicode characters
  - [ ] **2.1-UNIT-016 (P1)**: `TestPatternErrorMessage()` - Error message shows pattern and value
  - [ ] **2.1-UNIT-017 (P2)**: `TestPatternEmptyString()` - Empty string against pattern ".*" (should pass)
  - [ ] **2.1-UNIT-018 (P2)**: `TestPatternCaseSensitive()` - Patterns are case-sensitive by default

- [ ] **Task 5: Create Unit Tests for format** (AC: 5, 6, 7, 8, 9)
  - [ ] **2.1-UNIT-019 (P1)**: `TestFormatDateTime()` - Valid ISO 8601 date-time passes
  - [ ] **2.1-UNIT-020 (P1)**: `TestFormatDate()` - Valid ISO 8601 date passes
  - [ ] **2.1-UNIT-021 (P1)**: `TestFormatTime()` - Valid time format passes
  - [ ] **2.1-UNIT-022 (P1)**: `TestFormatEmail()` - Valid email addresses pass
  - [ ] **2.1-UNIT-023 (P1)**: `TestFormatUri()` - Valid URIs pass
  - [ ] **2.1-UNIT-024 (P1)**: `TestFormatUuid()` - Valid UUIDs pass
  - [ ] **2.1-UNIT-025 (P2)**: `TestFormatInvalidLenient()` - Invalid format is lenient (doesn't fail validation)
  - [ ] **2.1-UNIT-026 (P2)**: `TestFormatUnknown()` - Unknown format name is ignored
  - [ ] **2.1-UNIT-027 (P1)**: `TestFormatErrorKeyword()` - Error (if any) has keyword="format"

- [ ] **Task 6: Create Integration Tests** (AC: 3, 9)
  - [ ] **2.1-INT-001 (P1)**: `TestStringKeywordsCombined()` - Multiple string keywords in same schema
  - [ ] **2.1-INT-002 (P1)**: `TestStringKeywordsWithType()` - String keywords with type: "string"
  - [ ] **2.1-INT-003 (P2)**: `TestStringKeywordsNonString()` - String keywords ignored for non-string data

- [ ] **Task 7: Compile and Run All Tests** (AC: 9, 10)
  - [ ] Compile JSONSchema.Keyword.String using MCP tool
  - [ ] Compile Validator.cls using MCP tool
  - [ ] Compile test class using MCP tool
  - [ ] Run all tests using MCP tool `execute_unit_tests` with test_spec="Test.JSONSchema"
  - [ ] Verify all new tests pass (approximately 27 new tests)
  - [ ] Verify all existing tests still pass (93 tests from Epic 1)
  - [ ] Total expected: ~120 tests passing

## Dev Notes

### Previous Story Insights
[Source: docs/stories/1.1.story.md through 1.6.story.md]

**Key learnings from Epic 1:**
1. **Keyword Pattern**: Keyword validators are separate classes in `src/JSONSchema/Keyword/` directory
2. **ClassMethod Pattern**: All validators use `ClassMethod Validate(pData, pSchemaValue, pContext) As %Boolean`
3. **Error Reporting**: Use `pContext.AddError(keyword, message)` for validation failures
4. **Return Values**: Return 1 for valid, 0 for invalid
5. **ValidateNode Integration**: Validator.cls checks `pSchema.%IsDefined("keyword")` then calls keyword class
6. **Type Safety**: Check data type before applying type-specific validations
7. **Test Organization**: Per Story 1.6, organize tests by feature in separate files under 800 lines

### Project Structure
[Source: architecture/10-project-structure.md]

**Current Structure:**
```
src/JSONSchema/
├── Validator.cls
├── Context.cls
└── Keyword/
    ├── Type.cls       # Existing
    ├── Enum.cls       # Existing
    ├── Const.cls      # Existing
    └── String.cls     # NEW - Story 2.1
```

**Test Structure (per Story 1.6):**
```
src/Test/JSONSchema/
├── TestValidator.cls         # Foundation tests
├── TestTypeValidation.cls    # Type keyword tests
├── TestEnumConst.cls         # Enum/Const tests
├── TestInputFormats.cls      # Input format tests
├── TestStringKeywords.cls    # NEW - Story 2.1 (or add to existing file if <800 lines)
├── TestContext.cls           # Existing
└── TestPathTracking.cls      # Existing
```

### String Keyword Implementation Pattern
[Source: architecture/9-backend-architecture.md, src/JSONSchema/Keyword/Type.cls]

**Keyword Class Template:**
```objectscript
/// JSONSchema.Keyword.String - String constraint validators
/// <p>
/// Validates JSON Schema string keywords: minLength, maxLength, pattern, format
/// </p>
Class JSONSchema.Keyword.String Extends %RegisteredObject
{

/// Validate minLength constraint
/// @param pData The data to validate (must be string)
/// @param pMinLength Minimum length value from schema
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateMinLength(pData, pMinLength As %Integer, pContext As JSONSchema.Context) As %Boolean
{
    // Get actual length - $Length() handles Unicode correctly
    Set tActualLength = $Length(pData)

    If tActualLength < pMinLength {
        Set tMessage = "String length " _ tActualLength _ " is less than minLength " _ pMinLength
        Do pContext.AddError("minLength", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate maxLength constraint
ClassMethod ValidateMaxLength(pData, pMaxLength As %Integer, pContext As JSONSchema.Context) As %Boolean
{
    Set tActualLength = $Length(pData)

    If tActualLength > pMaxLength {
        Set tMessage = "String length " _ tActualLength _ " exceeds maxLength " _ pMaxLength
        Do pContext.AddError("maxLength", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate pattern constraint using regex
ClassMethod ValidatePattern(pData As %String, pPattern As %String, pContext As JSONSchema.Context) As %Boolean
{
    // Use ObjectScript $Match() for regex validation
    // $Match() returns 1 if string matches pattern, 0 otherwise
    If '$Match(pData, pPattern) {
        Set tMessage = "String does not match pattern /" _ pPattern _ "/"
        Do pContext.AddError("pattern", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate format constraint (lenient - format is advisory)
ClassMethod ValidateFormat(pData As %String, pFormat As %String, pContext As JSONSchema.Context) As %Boolean
{
    // Per JSON Schema spec, format is lenient - invalid format should not fail validation
    // We validate known formats but return 1 (pass) even if format is invalid
    // This allows strict mode in future if needed

    Set tValid = 1

    If pFormat = "date-time" {
        Set tValid = ..ValidateDateTime(pData)
    }
    ElseIf pFormat = "date" {
        Set tValid = ..ValidateDate(pData)
    }
    ElseIf pFormat = "time" {
        Set tValid = ..ValidateTime(pData)
    }
    ElseIf pFormat = "email" {
        Set tValid = ..ValidateEmail(pData)
    }
    ElseIf pFormat = "uri" {
        Set tValid = ..ValidateUri(pData)
    }
    ElseIf pFormat = "uuid" {
        Set tValid = ..ValidateUuid(pData)
    }
    // Unknown formats are ignored per spec

    // LENIENT MODE: Always return 1 (pass) even if format check failed
    // Could add error as warning in future enhancement
    Quit 1
}

/// Validate ISO 8601 date-time format
ClassMethod ValidateDateTime(pData As %String) As %Boolean
{
    // Basic ISO 8601 check: YYYY-MM-DDTHH:MM:SS or with timezone
    // Example: 2023-12-04T14:30:00Z or 2023-12-04T14:30:00+05:30
    Set tPattern = "^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})?$"
    Quit $Match(pData, tPattern)
}

/// Validate ISO 8601 date format
ClassMethod ValidateDate(pData As %String) As %Boolean
{
    // YYYY-MM-DD
    Set tPattern = "^\d{4}-\d{2}-\d{2}$"
    Quit $Match(pData, tPattern)
}

/// Validate time format
ClassMethod ValidateTime(pData As %String) As %Boolean
{
    // HH:MM:SS or HH:MM:SS.mmm
    Set tPattern = "^\d{2}:\d{2}:\d{2}(\.\d{1,3})?$"
    Quit $Match(pData, tPattern)
}

/// Validate email format (simple pattern)
ClassMethod ValidateEmail(pData As %String) As %Boolean
{
    // Simple email pattern: localpart@domain
    Set tPattern = "^[^@]+@[^@]+\.[^@]+$"
    Quit $Match(pData, tPattern)
}

/// Validate URI format
ClassMethod ValidateUri(pData As %String) As %Boolean
{
    // Basic URI pattern: scheme://host/path
    Set tPattern = "^[a-z][a-z0-9+.-]*:"
    Quit $Match(pData, tPattern)
}

/// Validate UUID format
ClassMethod ValidateUuid(pData As %String) As %Boolean
{
    // UUID format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    Set tPattern = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    Quit $Match(pData, tPattern)
}

}
```

### Validator.cls Integration Pattern
[Source: src/JSONSchema/Validator.cls lines 152-208]

**Adding String Keywords to ValidateNode():**
```objectscript
// In ValidateNode() method, after existing keyword checks (type, enum, const)

// String validation keywords (only apply to string data)
Set tDataType = ..GetJSONType(pData)
If tDataType = "string" {

    // Check minLength
    If $IsObject(pSchema) && pSchema.%IsDefined("minLength") {
        Set tMinLengthValid = ##class(JSONSchema.Keyword.String).ValidateMinLength(pData, pSchema.minLength, pContext)
        Set tValid = tValid && tMinLengthValid
    }

    // Check maxLength
    If $IsObject(pSchema) && pSchema.%IsDefined("maxLength") {
        Set tMaxLengthValid = ##class(JSONSchema.Keyword.String).ValidateMaxLength(pData, pSchema.maxLength, pContext)
        Set tValid = tValid && tMaxLengthValid
    }

    // Check pattern
    If $IsObject(pSchema) && pSchema.%IsDefined("pattern") {
        Set tPatternValid = ##class(JSONSchema.Keyword.String).ValidatePattern(pData, pSchema.pattern, pContext)
        Set tValid = tValid && tPatternValid
    }

    // Check format
    If $IsObject(pSchema) && pSchema.%IsDefined("format") {
        Set tFormatValid = ##class(JSONSchema.Keyword.String).ValidateFormat(pData, pSchema.format, pContext)
        Set tValid = tValid && tFormatValid
    }
}
```

### ObjectScript String and Regex Functions
[Source: architecture/3-tech-stack.md, ObjectScript documentation]

**Key ObjectScript Functions:**

| Function | Purpose | Example |
|----------|---------|---------|
| `$Length(string)` | Get string length (Unicode-aware) | `$Length("Hello")` = 5 |
| `$Match(string, pattern)` | Regex matching | `$Match("123", "^\d+$")` = 1 |
| `$Extract(string, start, end)` | Extract substring | `$Extract("Hello", 1, 2)` = "He" |

**CRITICAL - $Match() Pattern Syntax:**
- ObjectScript regex is similar to ECMAScript but has some differences
- Basic patterns: `^` (start), `$` (end), `.` (any char), `*` (0+), `+` (1+), `?` (0-1)
- Character classes: `\d` (digit), `\w` (word char), `\s` (whitespace)
- Ranges: `[a-z]`, `[0-9]`
- Grouping: `( )`
- Alternation: `|`

**ObjectScript $Match() vs ECMAScript Regex Compatibility:**
- ObjectScript regex is similar to ECMAScript but not identical
- Most common patterns work identically (^, $, ., *, +, ?, \d, \w, \s, [])
- Advanced features may differ (lookahead, lookbehind, backreferences, etc.)
- For JSON Schema Draft 7 compliance, basic patterns are sufficient
- JSON Schema spec recommends ECMAScript regex, but implementations may vary
- If pattern incompatibilities are discovered during testing, document them for users
- Future enhancement: Consider pattern compatibility validation or documentation

**Unicode Handling:**
- `$Length()` counts characters, not bytes (UTF-8 aware)
- Example: `$Length("Hello 世界")` = 8 (not byte count)

### Critical Coding Standards
[Source: architecture/15-coding-standards.md]

**Naming Conventions:**
- Parameters: `p` prefix (e.g., `pData`, `pMinLength`)
- Local Variables: `t` prefix (e.g., `tValid`, `tActualLength`)
- Class Methods: PascalCase (e.g., `ValidateMinLength`)

**CRITICAL - Macro Syntax:**
```objectscript
// ✓ CORRECT: Triple dollar signs ($$$)
Quit $$$OK
Do $$$AssertEquals(tValid, 1, "Should be valid")

// ✗ WRONG: Double dollar signs - WILL NOT COMPILE
Quit $$OK  // INCORRECT!
```

**CRITICAL - Return Pattern:**
```objectscript
// ✓ CORRECT: Argumentless QUIT in Try/Catch, return after
ClassMethod Validate(pData, pValue, pContext) As %Boolean
{
    Set tResult = 1
    Try {
        // Logic here
        If condition {
            Set tResult = 0
        }
        Quit  // Argumentless
    }
    Catch ex {
        Set tResult = 0
    }
    Quit tResult  // Return AFTER Try/Catch
}
```

### Testing Requirements
[Source: architecture/14-testing-strategy.md]

**Framework:** `%UnitTest.TestCase`
**Coverage Target:** 90%+
**Test File:** `src/Test/JSONSchema/TestStringKeywords.cls` (NEW) or add to existing file

**Test Method Pattern:**
```objectscript
Method TestMinLengthValid() As %Status
{
    Set tData = "Hello"
    Set tSchema = {"type": "string", "minLength": 3}
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "String length 5 should pass minLength 3")
    Do $$$AssertEquals(tErrors.%Size(), 0, "No errors expected")
    Quit $$$OK
}

Method TestMinLengthInvalid() As %Status
{
    Set tData = "Hi"
    Set tSchema = {"type": "string", "minLength": 3}
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "String length 2 should fail minLength 3")
    Do $$$AssertEquals(tErrors.%Size(), 1, "One error expected")
    Do $$$AssertEquals(tErrors.%Get(0).keyword, "minLength", "Error keyword should be minLength")
    Do $$$AssertTrue(tErrors.%Get(0).message [ "2", "Error should mention actual length")
    Do $$$AssertTrue(tErrors.%Get(0).message [ "3", "Error should mention minLength value")
    Quit $$$OK
}
```

### Format Validation Strategy

**Per JSON Schema Specification:**
- Format is an **annotation** and should be **lenient** by default
- Invalid format should NOT cause validation failure (advisory only)
- Implementations MAY choose to be strict (future enhancement)

**Current Implementation:**
- `ValidateFormat()` always returns 1 (pass)
- Format checking is performed but doesn't affect validation result
- Future enhancement: Add strict mode configuration

### Edge Cases to Consider

1. **Empty String:**
   - Length = 0
   - Passes maxLength >= 0
   - Fails minLength > 0
   - Pattern matching depends on pattern (e.g., ".*" matches empty)

2. **Unicode Characters:**
   - Use `$Length()` for character count (not byte count)
   - Example: "Hello 世界" = 8 characters
   - Regex patterns may need Unicode-aware patterns

3. **Pattern Edge Cases:**
   - Empty pattern `""` matches empty string
   - Pattern syntax errors should be caught during schema validation (future)
   - Case sensitivity: patterns are case-sensitive by default

4. **Format Edge Cases:**
   - Unknown formats are ignored (no error)
   - Invalid format values don't fail validation (lenient)
   - Format validators use simple regex patterns (not full RFC compliance)

### Test File Organization Decision

**Per Story 1.6 Standard:**
- Test files must not exceed 800 lines
- Organize by feature/keyword

**Options for Story 2.1:**
1. **Create new `TestStringKeywords.cls`** (RECOMMENDED)
   - Dedicated file for string keyword tests
   - Estimated: ~27 tests × ~20 lines = ~540 lines (under limit ✓)
   - Clear feature grouping

2. **Add to existing test file**
   - Only if existing file has <260 lines available
   - Check file size first

**Decision:** Create `TestStringKeywords.cls` to maintain clear feature separation and allow room for future string keyword tests.

### Tech Stack Summary
[Source: architecture/3-tech-stack.md]

| Component | Technology | Version | Purpose |
|-----------|------------|---------|---------|
| Backend Language | ObjectScript | IRIS 2020.1+ | Keyword validators |
| String Functions | $Length, $Match | Native | Length and regex |
| Testing | %UnitTest.TestCase | Native | Unit tests |

## Testing

### Test File Location
`src/Test/JSONSchema/TestStringKeywords.cls` (NEW)

### Testing Standards
- Use `%UnitTest.TestCase` framework
- Test methods must start with `Test` prefix
- All test methods must return `%Status` (return `$$$OK`)
- Use `$$$AssertTrue()`, `$$$AssertEquals()` macros
- Triple dollar signs ($$$) required for all macros

### Test Execution Strategy

**Phase 1: Compile Classes**
- Compile JSONSchema.Keyword.String
- Compile Validator.cls
- Compile TestStringKeywords.cls

**Phase 2: Run Tests**
- Execute: `Do ##class(%UnitTest.Manager).RunTest("Test.JSONSchema")`
- Or via MCP: `execute_unit_tests` with test_spec="Test.JSONSchema.TestStringKeywords"
- Verify all 27 new tests pass
- Verify all 93 existing tests still pass (regression check)

**Expected Results:**
- 27 new tests pass (string keywords)
- 93 existing tests pass (Epic 1)
- Total: ~120 tests passing
- Test execution time: <3 seconds

### Test Coverage Matrix

| Keyword | Valid Cases | Invalid Cases | Edge Cases | Total |
|---------|-------------|---------------|------------|-------|
| minLength | 2 tests | 1 test | 2 tests | 5 tests |
| maxLength | 2 tests | 1 test | 2 tests | 5 tests |
| Combined | 1 test | - | - | 1 test |
| pattern | 3 tests | 1 test | 4 tests | 8 tests |
| format | 6 formats | 1 test | 2 tests | 9 tests |
| **Total** | **14** | **4** | **10** | **28 tests** |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.1 | Story approved after PO validation - Added regex compatibility note - Implementation Readiness Score: 9.5/10 | PO Agent (Sarah) |
| 2025-12-04 | 1.0 | Initial story draft for string validation keywords (Epic 2, Story 1) | SM Agent (Bob) |

---

## Dev Agent Record

### Agent Model Used
_[To be filled by dev agent]_

### Debug Log References
_[To be filled by dev agent]_

### Completion Notes List
_[To be filled by dev agent]_

### File List
_[To be filled by dev agent]_

---

## QA Results

_[To be filled by QA agent after implementation review]_
