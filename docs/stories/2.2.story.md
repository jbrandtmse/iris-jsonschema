# Story 2.2: Numeric Validation Keywords

## Status

**Draft**

## Story

**As a** developer,
**I want** the validator to enforce numeric constraints,
**so that** I can validate number ranges and precision.

## Acceptance Criteria

1. `minimum` keyword validates number >= specified value
2. `maximum` keyword validates number <= specified value
3. `exclusiveMinimum` keyword validates number > specified value
4. `exclusiveMaximum` keyword validates number < specified value
5. `multipleOf` keyword validates number is a multiple of specified value
6. All numeric keywords work with both integers and floating-point numbers
7. `multipleOf` handles floating-point precision correctly
8. Error messages show expected constraint vs actual value
9. Unit tests cover boundary conditions (exactly at min/max)
10. Unit tests cover floating-point edge cases

## Tasks / Subtasks

- [ ] **Task 1: Create JSONSchema.Keyword.Numeric.cls** (AC: 1, 2, 3, 4, 5, 6, 7, 8)
  - [ ] Create file: `src/JSONSchema/Keyword/Numeric.cls`
  - [ ] Add class header and documentation following existing pattern (see String.cls)
  - [ ] Implement `ValidateMinimum(pData, pMinimum, pContext)` ClassMethod
  - [ ] Implement `ValidateMaximum(pData, pMaximum, pContext)` ClassMethod
  - [ ] Implement `ValidateExclusiveMinimum(pData, pExclusiveMinimum, pContext)` ClassMethod
  - [ ] Implement `ValidateExclusiveMaximum(pData, pExclusiveMaximum, pContext)` ClassMethod
  - [ ] Implement `ValidateMultipleOf(pData, pMultipleOf, pContext)` ClassMethod with floating-point precision handling
  - [ ] Ensure all methods handle both integers and floating-point numbers
  - [ ] Add comprehensive error messages showing actual vs expected values
  - [ ] Compile using MCP tool `compile_objectscript_class`

- [ ] **Task 2: Update Validator.cls to Call Numeric Keywords** (AC: 1, 2, 3, 4, 5, 6)
  - [ ] Update `ValidateNode()` method in Validator.cls
  - [ ] Add numeric type check: `If (tDataType = "number") || (tDataType = "integer")`
  - [ ] Add check for `minimum` keyword: `If pSchema.%IsDefined("minimum")`
  - [ ] Add check for `maximum` keyword: `If pSchema.%IsDefined("maximum")`
  - [ ] Add check for `exclusiveMinimum` keyword: `If pSchema.%IsDefined("exclusiveMinimum")`
  - [ ] Add check for `exclusiveMaximum` keyword: `If pSchema.%IsDefined("exclusiveMaximum")`
  - [ ] Add check for `multipleOf` keyword: `If pSchema.%IsDefined("multipleOf")`
  - [ ] Call numeric keyword validators only if data is a number or integer type
  - [ ] Compile Validator.cls using MCP tool

- [ ] **Task 3: Create Unit Tests for minimum and maximum** (AC: 1, 2, 6, 8, 9)
  - [ ] Create test file: `src/Test/JSONSchema/TestNumericKeywords.cls`
  - [ ] **2.2-UNIT-001 (P0)**: `TestMinimumValid()` - Number >= minimum passes
  - [ ] **2.2-UNIT-002 (P0)**: `TestMinimumInvalid()` - Number < minimum fails
  - [ ] **2.2-UNIT-003 (P1)**: `TestMinimumBoundary()` - Number exactly equal to minimum passes
  - [ ] **2.2-UNIT-004 (P0)**: `TestMaximumValid()` - Number <= maximum passes
  - [ ] **2.2-UNIT-005 (P0)**: `TestMaximumInvalid()` - Number > maximum fails
  - [ ] **2.2-UNIT-006 (P1)**: `TestMaximumBoundary()` - Number exactly equal to maximum passes
  - [ ] **2.2-UNIT-007 (P0)**: `TestMinMaxCombined()` - Both constraints work together
  - [ ] **2.2-UNIT-008 (P1)**: `TestMinimumFloat()` - Floating-point minimum validation
  - [ ] **2.2-UNIT-009 (P1)**: `TestMaximumFloat()` - Floating-point maximum validation
  - [ ] **2.2-UNIT-010 (P1)**: `TestMinimumNegative()` - Negative minimum values work correctly

- [ ] **Task 4: Create Unit Tests for exclusiveMinimum and exclusiveMaximum** (AC: 3, 4, 6, 8, 9)
  - [ ] **2.2-UNIT-011 (P0)**: `TestExclusiveMinimumValid()` - Number > exclusiveMinimum passes
  - [ ] **2.2-UNIT-012 (P0)**: `TestExclusiveMinimumInvalid()` - Number <= exclusiveMinimum fails
  - [ ] **2.2-UNIT-013 (P1)**: `TestExclusiveMinimumBoundary()` - Number exactly equal to exclusiveMinimum fails
  - [ ] **2.2-UNIT-014 (P0)**: `TestExclusiveMaximumValid()` - Number < exclusiveMaximum passes
  - [ ] **2.2-UNIT-015 (P0)**: `TestExclusiveMaximumInvalid()` - Number >= exclusiveMaximum fails
  - [ ] **2.2-UNIT-016 (P1)**: `TestExclusiveMaximumBoundary()` - Number exactly equal to exclusiveMaximum fails
  - [ ] **2.2-UNIT-017 (P1)**: `TestExclusiveCombined()` - exclusiveMinimum and exclusiveMaximum together
  - [ ] **2.2-UNIT-018 (P1)**: `TestMixedMinMaxExclusive()` - minimum with exclusiveMaximum

- [ ] **Task 5: Create Unit Tests for multipleOf** (AC: 5, 6, 7, 8, 10)
  - [ ] **2.2-UNIT-019 (P0)**: `TestMultipleOfValid()` - Number that is exact multiple passes
  - [ ] **2.2-UNIT-020 (P0)**: `TestMultipleOfInvalid()` - Number that is not multiple fails
  - [ ] **2.2-UNIT-021 (P1)**: `TestMultipleOfInteger()` - Integer multipleOf validation
  - [ ] **2.2-UNIT-022 (P1)**: `TestMultipleOfFloat()` - Floating-point multipleOf (e.g., multipleOf: 0.1)
  - [ ] **2.2-UNIT-023 (P2)**: `TestMultipleOfFloatPrecision()` - Floating-point precision edge case (e.g., 0.1 + 0.2 = 0.3)
  - [ ] **2.2-UNIT-024 (P1)**: `TestMultipleOfZero()` - Data value 0 is multiple of any positive number
  - [ ] **2.2-UNIT-025 (P1)**: `TestMultipleOfNegative()` - Negative numbers with multipleOf
  - [ ] **2.2-UNIT-026 (P1)**: `TestMultipleOfErrorMessage()` - Error message shows value and multipleOf

- [ ] **Task 6: Create Integration Tests** (AC: 6, 9)
  - [ ] **2.2-INT-001 (P1)**: `TestNumericKeywordsCombined()` - Multiple numeric keywords in same schema
  - [ ] **2.2-INT-002 (P1)**: `TestNumericKeywordsWithType()` - Numeric keywords with type: "number" or "integer"
  - [ ] **2.2-INT-003 (P2)**: `TestNumericKeywordsNonNumeric()` - Numeric keywords ignored for non-numeric data

- [ ] **Task 7: Compile and Run All Tests** (AC: 9, 10)
  - [ ] Compile JSONSchema.Keyword.Numeric using MCP tool
  - [ ] Compile Validator.cls using MCP tool
  - [ ] Compile TestNumericKeywords.cls using MCP tool
  - [ ] Run all tests using MCP tool `execute_unit_tests` with test_spec="Test.JSONSchema"
  - [ ] Verify all new tests pass (approximately 29 new tests)
  - [ ] Verify all existing tests still pass (~123 tests from Epic 1 + Story 2.1)
  - [ ] Total expected: ~152 tests passing

## Dev Notes

### Previous Story Insights
[Source: docs/stories/2.1.story.md - Dev Agent Record]

**Key learnings from Story 2.1 (String Keywords):**
1. **Keyword Class Pattern**: Create separate class in `src/JSONSchema/Keyword/` directory
2. **ClassMethod Pattern**: All validators use `ClassMethod ValidateX(pData, pSchemaValue, pContext) As %Boolean`
3. **Error Reporting**: Use `pContext.AddError(keyword, message)` for validation failures
4. **Return Values**: Return 1 for valid, 0 for invalid
5. **ValidateNode Integration**: Check data type first, then check `pSchema.%IsDefined("keyword")` then call keyword class
6. **Test Organization**: Create dedicated test file per feature (e.g., `TestStringKeywords.cls` for string, `TestNumericKeywords.cls` for numeric)
7. **All 123 tests currently passing** - do not break existing tests

### Project Structure
[Source: architecture/10-project-structure.md]

**Current Structure:**
```
src/JSONSchema/
├── Validator.cls
├── Context.cls
└── Keyword/
    ├── Type.cls       # Existing
    ├── Enum.cls       # Existing
    ├── Const.cls      # Existing
    ├── String.cls     # Existing (Story 2.1)
    └── Numeric.cls    # NEW - Story 2.2
```

**Test Structure:**
```
src/Test/JSONSchema/
├── TestValidator.cls         # Foundation tests
├── TestTypeValidation.cls    # Type keyword tests
├── TestEnumConst.cls         # Enum/Const tests
├── TestInputFormats.cls      # Input format tests
├── TestStringKeywords.cls    # String keyword tests (Story 2.1)
├── TestNumericKeywords.cls   # NEW - Story 2.2
├── TestContext.cls           # Existing
└── TestPathTracking.cls      # Existing
```

### Numeric Keyword Implementation Pattern
[Source: architecture/9-backend-architecture.md, src/JSONSchema/Keyword/String.cls]

**Keyword Class Template:**
```objectscript
/// JSONSchema.Keyword.Numeric - Numeric constraint validators
/// <p>
/// Validates JSON Schema numeric keywords: minimum, maximum,
/// exclusiveMinimum, exclusiveMaximum, multipleOf
/// </p>
Class JSONSchema.Keyword.Numeric Extends %RegisteredObject
{

/// Validate minimum constraint
/// @param pData The numeric data to validate
/// @param pMinimum Minimum value from schema
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateMinimum(pData, pMinimum, pContext As JSONSchema.Context) As %Boolean
{
    If pData < pMinimum {
        Set tMessage = "Value " _ pData _ " is less than minimum " _ pMinimum
        Do pContext.AddError("minimum", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate maximum constraint
ClassMethod ValidateMaximum(pData, pMaximum, pContext As JSONSchema.Context) As %Boolean
{
    If pData > pMaximum {
        Set tMessage = "Value " _ pData _ " exceeds maximum " _ pMaximum
        Do pContext.AddError("maximum", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate exclusiveMinimum constraint (Draft 7 style - value must be > exclusiveMinimum)
ClassMethod ValidateExclusiveMinimum(pData, pExclusiveMinimum, pContext As JSONSchema.Context) As %Boolean
{
    If pData <= pExclusiveMinimum {
        Set tMessage = "Value " _ pData _ " is not greater than exclusiveMinimum " _ pExclusiveMinimum
        Do pContext.AddError("exclusiveMinimum", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate exclusiveMaximum constraint (Draft 7 style - value must be < exclusiveMaximum)
ClassMethod ValidateExclusiveMaximum(pData, pExclusiveMaximum, pContext As JSONSchema.Context) As %Boolean
{
    If pData >= pExclusiveMaximum {
        Set tMessage = "Value " _ pData _ " is not less than exclusiveMaximum " _ pExclusiveMaximum
        Do pContext.AddError("exclusiveMaximum", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate multipleOf constraint with floating-point precision handling
/// @param pData The numeric data to validate
/// @param pMultipleOf The divisor value from schema
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateMultipleOf(pData, pMultipleOf, pContext As JSONSchema.Context) As %Boolean
{
    // Handle zero data - 0 is a multiple of any positive number
    If pData = 0 {
        Quit 1
    }

    // Calculate remainder using modulo
    // For floating-point precision, check if remainder is effectively zero
    Set tRemainder = pData # pMultipleOf

    // Handle floating-point precision issues
    // Consider it a valid multiple if remainder is very close to 0 or to pMultipleOf
    Set tEpsilon = 0.0000001
    If ($ZAbs(tRemainder) < tEpsilon) || ($ZAbs(tRemainder - pMultipleOf) < tEpsilon) {
        Quit 1
    }

    Set tMessage = "Value " _ pData _ " is not a multiple of " _ pMultipleOf
    Do pContext.AddError("multipleOf", tMessage)
    Quit 0
}

}
```

### Validator.cls Integration Pattern
[Source: src/JSONSchema/Validator.cls lines 197-224]

**Adding Numeric Keywords to ValidateNode() - add AFTER string keyword section:**
```objectscript
// Numeric validation keywords (only apply to numeric data)
If (tDataType = "number") || (tDataType = "integer") {

    // Check minimum
    If $IsObject(pSchema) && pSchema.%IsDefined("minimum") {
        Set tMinimumValid = ##class(JSONSchema.Keyword.Numeric).ValidateMinimum(pData, pSchema.minimum, pContext)
        Set tValid = tValid && tMinimumValid
    }

    // Check maximum
    If $IsObject(pSchema) && pSchema.%IsDefined("maximum") {
        Set tMaximumValid = ##class(JSONSchema.Keyword.Numeric).ValidateMaximum(pData, pSchema.maximum, pContext)
        Set tValid = tValid && tMaximumValid
    }

    // Check exclusiveMinimum
    If $IsObject(pSchema) && pSchema.%IsDefined("exclusiveMinimum") {
        Set tExMinValid = ##class(JSONSchema.Keyword.Numeric).ValidateExclusiveMinimum(pData, pSchema.exclusiveMinimum, pContext)
        Set tValid = tValid && tExMinValid
    }

    // Check exclusiveMaximum
    If $IsObject(pSchema) && pSchema.%IsDefined("exclusiveMaximum") {
        Set tExMaxValid = ##class(JSONSchema.Keyword.Numeric).ValidateExclusiveMaximum(pData, pSchema.exclusiveMaximum, pContext)
        Set tValid = tValid && tExMaxValid
    }

    // Check multipleOf
    If $IsObject(pSchema) && pSchema.%IsDefined("multipleOf") {
        Set tMultipleValid = ##class(JSONSchema.Keyword.Numeric).ValidateMultipleOf(pData, pSchema.multipleOf, pContext)
        Set tValid = tValid && tMultipleValid
    }
}
```

### ObjectScript Numeric Functions
[Source: architecture/3-tech-stack.md, ObjectScript documentation]

**Key ObjectScript Functions:**

| Function | Purpose | Example |
|----------|---------|---------|
| `#` | Modulo operator | `10 # 3` = 1 |
| `$ZAbs(n)` | Absolute value | `$ZAbs(-5)` = 5 |
| `\` | Integer division | `10 \ 3` = 3 |

**CRITICAL - Floating-Point Precision:**
- ObjectScript handles floating-point arithmetic
- For multipleOf with decimals (e.g., 0.1), use epsilon comparison
- Example: `0.1 + 0.2` may not equal exactly `0.3` due to IEEE 754 representation
- Use `$ZAbs(remainder) < epsilon` pattern for floating-point comparisons
- Recommended epsilon: `0.0000001` (1e-7)

**JSON Schema Draft 7 Numeric Keywords:**
- `minimum`: Number must be >= this value (inclusive)
- `maximum`: Number must be <= this value (inclusive)
- `exclusiveMinimum`: Number must be > this value (exclusive, Draft 7 is just a number)
- `exclusiveMaximum`: Number must be < this value (exclusive, Draft 7 is just a number)
- `multipleOf`: Number must be evenly divisible by this value

### Critical Coding Standards
[Source: architecture/15-coding-standards.md]

**Naming Conventions:**
- Parameters: `p` prefix (e.g., `pData`, `pMinimum`)
- Local Variables: `t` prefix (e.g., `tValid`, `tRemainder`)
- Class Methods: PascalCase (e.g., `ValidateMinimum`)

**CRITICAL - Macro Syntax:**
```objectscript
// CORRECT: Triple dollar signs ($$$)
Quit $$$OK
Do $$$AssertEquals(tValid, 1, "Should be valid")

// WRONG: Double dollar signs - WILL NOT COMPILE
Quit $$OK  // INCORRECT!
```

**CRITICAL - Return Pattern:**
```objectscript
// Simple pattern for boolean returns (no Try/Catch needed for simple comparisons)
ClassMethod ValidateMinimum(pData, pMinimum, pContext) As %Boolean
{
    If pData < pMinimum {
        Do pContext.AddError("minimum", "message")
        Quit 0
    }
    Quit 1
}
```

### Edge Cases to Consider

1. **Boundary Values:**
   - Value exactly at minimum (passes for minimum, fails for exclusiveMinimum)
   - Value exactly at maximum (passes for maximum, fails for exclusiveMaximum)
   - Zero values

2. **Floating-Point Numbers:**
   - Decimal comparisons (e.g., 10.5 >= 10.5)
   - multipleOf with decimals (e.g., 0.7 is multipleOf 0.1)
   - IEEE 754 precision issues (0.1 + 0.2 != 0.3)

3. **Negative Numbers:**
   - Negative minimums (e.g., minimum: -100)
   - Negative ranges (e.g., -50 to -10)
   - multipleOf with negative data

4. **Integer vs Number:**
   - Both types should validate against all numeric keywords
   - Integer 5 should pass minimum: 5.0
   - Float 5.0 should pass minimum: 5

5. **Zero Special Cases:**
   - 0 is a multiple of any positive number
   - 0 can be minimum or maximum value

### Tech Stack Summary
[Source: architecture/3-tech-stack.md]

| Component | Technology | Version | Purpose |
|-----------|------------|---------|---------|
| Backend Language | ObjectScript | IRIS 2020.1+ | Keyword validators |
| Numeric Functions | #, $ZAbs, \ | Native | Modulo, absolute value, division |
| Testing | %UnitTest.TestCase | Native | Unit tests |

## Testing

### Test File Location
`src/Test/JSONSchema/TestNumericKeywords.cls` (NEW)

### Testing Standards
- Use `%UnitTest.TestCase` framework
- Test methods must start with `Test` prefix
- All test methods must return `%Status` (return `$$$OK`)
- Use `$$$AssertTrue()`, `$$$AssertEquals()` macros
- Triple dollar signs ($$$) required for all macros

### Test Method Pattern
```objectscript
Method TestMinimumValid() As %Status
{
    Set tData = 10
    Set tSchema = {"type": "number", "minimum": 5}
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Value 10 should pass minimum 5")
    Do $$$AssertEquals(tErrors.%Size(), 0, "No errors expected")
    Quit $$$OK
}

Method TestMinimumInvalid() As %Status
{
    Set tData = 3
    Set tSchema = {"type": "number", "minimum": 5}
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Value 3 should fail minimum 5")
    Do $$$AssertEquals(tErrors.%Size(), 1, "One error expected")
    Do $$$AssertEquals(tErrors.%Get(0).keyword, "minimum", "Error keyword should be minimum")
    Quit $$$OK
}

Method TestMultipleOfFloatPrecision() As %Status
{
    // Test floating-point precision: 0.7 should be multipleOf 0.1
    Set tData = 0.7
    Set tSchema = {"multipleOf": 0.1}
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "0.7 should be valid multipleOf 0.1")
    Quit $$$OK
}
```

### Test Execution Strategy

**Phase 1: Compile Classes**
- Compile JSONSchema.Keyword.Numeric
- Compile Validator.cls
- Compile TestNumericKeywords.cls

**Phase 2: Run Tests**
- Execute via MCP: `execute_unit_tests` with test_spec="Test.JSONSchema"
- Verify all 29 new tests pass
- Verify all 123 existing tests still pass (regression check)

**Expected Results:**
- 29 new tests pass (numeric keywords)
- 123 existing tests pass (Epic 1 + Story 2.1)
- Total: ~152 tests passing
- Test execution time: <5 seconds

### Test Coverage Matrix

| Keyword | Valid Cases | Invalid Cases | Boundary | Edge Cases | Total |
|---------|-------------|---------------|----------|------------|-------|
| minimum | 2 tests | 1 test | 1 test | 2 tests | 6 tests |
| maximum | 2 tests | 1 test | 1 test | 1 test | 5 tests |
| exclusiveMinimum | 1 test | 1 test | 1 test | - | 3 tests |
| exclusiveMaximum | 1 test | 1 test | 1 test | - | 3 tests |
| Combined excl | 2 tests | - | - | - | 2 tests |
| multipleOf | 2 tests | 1 test | - | 5 tests | 8 tests |
| Integration | 3 tests | - | - | - | 3 tests |
| **Total** | **13** | **5** | **4** | **8** | **30 tests** |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.1 | Story approved after PO validation - Implementation Readiness Score: 9.5/10 | PO Agent (Sarah) |
| 2025-12-04 | 1.0 | Initial story draft for numeric validation keywords (Epic 2, Story 2) | SM Agent (Bob) |

---

## Dev Agent Record

### Agent Model Used
_[To be filled by dev agent]_

### Debug Log References
_[To be filled by dev agent]_

### Completion Notes List
_[To be filled by dev agent]_

### File List
| File | Action | Description |
|------|--------|-------------|
| _[To be filled by dev agent]_ | | |

---

## QA Results

_[To be filled by QA agent after implementation review]_
