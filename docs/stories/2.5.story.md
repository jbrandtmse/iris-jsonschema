# Story 2.5: Schema Combinators

## Status

**Done**

## Story

**As a** developer,
**I want** the validator to support allOf, anyOf, oneOf, and not combinators,
**so that** I can create complex schemas combining multiple sub-schemas.

## Acceptance Criteria

1. `allOf` validates data matches ALL schemas in the array
2. `anyOf` validates data matches AT LEAST ONE schema in the array
3. `oneOf` validates data matches EXACTLY ONE schema in the array
4. `not` validates data does NOT match the specified schema
5. Combinators work with nested combinators (e.g., `allOf` containing `anyOf`)
6. Combinators work with all other keywords (type, properties, etc.)
7. `oneOf` correctly fails when data matches zero schemas
8. `oneOf` correctly fails when data matches more than one schema
9. Error messages for `anyOf`/`oneOf` indicate which sub-schemas were attempted
10. Error messages for `allOf` indicate which sub-schema failed
11. Unit tests cover complex nested combinator scenarios
12. Unit tests verify correct behavior when combinators reference `$ref`

## Tasks / Subtasks

- [x] **Task 1: Create JSONSchema.Keyword.Combinator.cls** (AC: 1, 2, 3, 4, 9, 10)
  - [x] Create file: `src/JSONSchema/Keyword/Combinator.cls`
  - [x] Add class header and documentation following existing pattern (see Object.cls, Array.cls)
  - [x] Implement `ValidateAllOf(pData, pSchemas, pContext)` ClassMethod
    - [x] Iterate through all schemas in the array
    - [x] Validate data against each schema using ValidateNode
    - [x] Return valid only if ALL schemas pass
    - [x] Track and report which sub-schema(s) failed
  - [x] Implement `ValidateAnyOf(pData, pSchemas, pContext)` ClassMethod
    - [x] Iterate through schemas checking if at least one matches
    - [x] Use temporary context for each attempt to avoid polluting errors
    - [x] Return valid if ANY schema passes
    - [x] If all fail, report attempted schemas in error message
  - [x] Implement `ValidateOneOf(pData, pSchemas, pContext)` ClassMethod
    - [x] Iterate through all schemas counting matches
    - [x] Use temporary context for each validation
    - [x] Return valid only if EXACTLY ONE schema matches
    - [x] Fail with message if zero schemas match
    - [x] Fail with message if more than one schema matches (list which ones)
  - [x] Implement `ValidateNot(pData, pSchema, pContext)` ClassMethod
    - [x] Validate data against schema using temporary context
    - [x] Return valid if schema validation FAILS
    - [x] Return invalid if schema validation PASSES
  - [x] Compile using MCP tool `compile_objectscript_class`

- [x] **Task 2: Integrate Combinators into ValidateNode()** (AC: 1, 2, 3, 4, 5, 6)
  - [x] Add combinator checks in ValidateNode() (BEFORE type-specific checks)
  - [x] Combinator validation pattern:
    - [x] Check `pSchema.%IsDefined("allOf")` -> Call Combinator.ValidateAllOf()
    - [x] Check `pSchema.%IsDefined("anyOf")` -> Call Combinator.ValidateAnyOf()
    - [x] Check `pSchema.%IsDefined("oneOf")` -> Call Combinator.ValidateOneOf()
    - [x] Check `pSchema.%IsDefined("not")` -> Call Combinator.ValidateNot()
  - [x] Ensure combinators compose with other keywords (type, properties, etc.)
  - [x] Compile Validator.cls using MCP tool

- [x] **Task 3: Create Unit Tests for allOf** (AC: 1, 5, 6, 10)
  - [x] Create test file: `src/Test/JSONSchema/TestCombinators.cls`
  - [x] **2.5-UNIT-001 (P0)**: `TestAllOfValid()` - Data matches all schemas passes
  - [x] **2.5-UNIT-002 (P0)**: `TestAllOfInvalid()` - Data fails one schema fails
  - [x] **2.5-UNIT-003 (P1)**: `TestAllOfErrorMessage()` - Error indicates which sub-schema failed
  - [x] **2.5-UNIT-004 (P1)**: `TestAllOfMultipleConstraints()` - allOf combines type + properties
  - [x] **2.5-UNIT-005 (P1)**: `TestAllOfNested()` - allOf containing allOf

- [x] **Task 4: Create Unit Tests for anyOf** (AC: 2, 5, 6, 9)
  - [x] **2.5-UNIT-006 (P0)**: `TestAnyOfValid()` - Data matches one schema passes
  - [x] **2.5-UNIT-007 (P0)**: `TestAnyOfValidMultiple()` - Data matches multiple schemas passes
  - [x] **2.5-UNIT-008 (P0)**: `TestAnyOfInvalid()` - Data matches no schemas fails
  - [x] **2.5-UNIT-009 (P1)**: `TestAnyOfErrorMessage()` - Error shows attempted schemas
  - [x] **2.5-UNIT-010 (P1)**: `TestAnyOfWithType()` - anyOf with type constraints

- [x] **Task 5: Create Unit Tests for oneOf** (AC: 3, 5, 6, 7, 8, 9)
  - [x] **2.5-UNIT-011 (P0)**: `TestOneOfValid()` - Data matches exactly one schema passes
  - [x] **2.5-UNIT-012 (P0)**: `TestOneOfZeroMatches()` - Data matches no schemas fails
  - [x] **2.5-UNIT-013 (P0)**: `TestOneOfMultipleMatches()` - Data matches 2+ schemas fails
  - [x] **2.5-UNIT-014 (P1)**: `TestOneOfErrorZero()` - Error message when zero match
  - [x] **2.5-UNIT-015 (P1)**: `TestOneOfErrorMultiple()` - Error message shows which schemas matched
  - [x] **2.5-UNIT-016 (P1)**: `TestOneOfWithProperties()` - oneOf selecting object variants

- [x] **Task 6: Create Unit Tests for not** (AC: 4, 5, 6)
  - [x] **2.5-UNIT-017 (P0)**: `TestNotValid()` - Data NOT matching schema passes
  - [x] **2.5-UNIT-018 (P0)**: `TestNotInvalid()` - Data matching schema fails
  - [x] **2.5-UNIT-019 (P1)**: `TestNotWithType()` - not with type constraint
  - [x] **2.5-UNIT-020 (P1)**: `TestNotWithEnum()` - not with enum constraint
  - [x] **2.5-UNIT-021 (P1)**: `TestNotNested()` - not containing allOf

- [x] **Task 7: Create Integration Tests** (AC: 5, 6, 11, 12)
  - [x] **2.5-INT-001 (P1)**: `TestNestedCombinators()` - allOf with anyOf inside
  - [x] **2.5-INT-002 (P1)**: `TestCombinatorWithArrayItems()` - items schema using oneOf
  - [x] **2.5-INT-003 (P1)**: `TestCombinatorWithObjectProps()` - property using anyOf
  - [x] **2.5-INT-004 (P1)**: `TestComplexNesting()` - Deep combinator nesting scenario
  - [x] **2.5-INT-005 (P2)**: `TestCombinatorErrorPaths()` - Error paths through combinators
  - [x] **2.5-INT-006 (P2)**: `TestCombinatorWithRef()` - Combinator referencing $ref (placeholder for Story 2.7)

- [x] **Task 8: Compile and Run All Tests** (AC: 11, 12)
  - [x] Compile JSONSchema.Keyword.Combinator using MCP tool
  - [x] Compile Validator.cls using MCP tool
  - [x] Compile TestCombinators.cls using MCP tool
  - [x] Run all tests using MCP tool `execute_unit_tests` with test_spec="Test.JSONSchema"
  - [x] Verify all new tests pass (27 new tests: 21 unit + 6 integration)
  - [x] Verify all existing tests still pass (~216 tests from Epic 1 + Stories 2.1-2.4)
  - [x] Total expected: ~243 tests passing

## Dev Notes

### Previous Story Insights
[Source: docs/stories/2.4.story.md - Dev Agent Record]

**Key learnings from Story 2.4 (Array Keywords):**
1. **Temporary Context Pattern**: For `contains` validation, created temporary context to avoid polluting errors - CRITICAL for anyOf/oneOf
2. **Boolean Type Loss Issue**: When extracting values from `%DynamicArray`, booleans become integers (true->1). Use `%GetTypeOf()` before extraction
3. **Validation Return Pattern**: Use `Set tFound = 1` flag pattern then check after loop, don't rely on Quit from inside While loop
4. **All 216 tests currently passing** - do not break existing tests

### Project Structure
[Source: architecture/10-project-structure.md]

**Current Structure:**
```
src/JSONSchema/
├── Validator.cls
├── Context.cls
└── Keyword/
    ├── Type.cls       # Existing
    ├── Enum.cls       # Existing
    ├── Const.cls      # Existing
    ├── String.cls     # Existing (Story 2.1)
    ├── Numeric.cls    # Existing (Story 2.2)
    ├── Object.cls     # Existing (Story 2.3)
    ├── Array.cls      # Existing (Story 2.4)
    └── Combinator.cls # NEW - Story 2.5
```

**Test Structure:**
```
src/Test/JSONSchema/
├── TestValidator.cls         # Foundation tests
├── TestTypeValidation.cls    # Type keyword tests
├── TestEnumConst.cls         # Enum/Const tests
├── TestInputFormats.cls      # Input format tests
├── TestStringKeywords.cls    # String keyword tests (Story 2.1)
├── TestNumericKeywords.cls   # Numeric keyword tests (Story 2.2)
├── TestObjectKeywords.cls    # Object keyword tests (Story 2.3)
├── TestArrayKeywords.cls     # Array keyword tests (Story 2.4)
├── TestContext.cls           # Existing
├── TestPathTracking.cls      # Existing
└── TestCombinators.cls       # NEW - Story 2.5
```

### Combinator Implementation Pattern
[Source: architecture/9-backend-architecture.md, JSON Schema Draft 7 Specification]

**Keyword Class Template:**
```objectscript
/// JSONSchema.Keyword.Combinator - Schema combinator validators
/// <p>
/// Validates JSON Schema combinator keywords: allOf, anyOf, oneOf, not
/// </p>
Class JSONSchema.Keyword.Combinator Extends %RegisteredObject
{

/// Validate allOf constraint - data must match ALL schemas
/// @param pData The data to validate
/// @param pSchemas %DynamicArray of schemas
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateAllOf(pData, pSchemas As %DynamicArray, pContext As JSONSchema.Context) As %Boolean
{
    Set tValid = 1
    Set tIter = pSchemas.%GetIterator()

    While tIter.%GetNext(.tIndex, .tSchema) {
        // Validate against each schema - errors accumulate in context
        Set tSchemaValid = ##class(JSONSchema.Validator).ValidateNode(pData, tSchema, pContext)
        If 'tSchemaValid {
            Set tValid = 0
            // Continue to check remaining schemas for complete error reporting
        }
    }

    If 'tValid {
        Do pContext.AddError("allOf", "Data does not match all schemas in allOf")
    }

    Quit tValid
}

/// Validate anyOf constraint - data must match AT LEAST ONE schema
/// @param pData The data to validate
/// @param pSchemas %DynamicArray of schemas
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateAnyOf(pData, pSchemas As %DynamicArray, pContext As JSONSchema.Context) As %Boolean
{
    Set tMatched = 0
    Set tIter = pSchemas.%GetIterator()

    While tIter.%GetNext(.tIndex, .tSchema) {
        // Use temporary context to avoid polluting main error list
        Set tTempContext = ##class(JSONSchema.Context).%New()
        Set tTempContext.RootSchema = pContext.RootSchema

        Set tSchemaValid = ##class(JSONSchema.Validator).ValidateNode(pData, tSchema, tTempContext)
        If tSchemaValid {
            Set tMatched = 1
            Quit  // Exit loop - found a match
        }
    }

    If 'tMatched {
        Set tMessage = "Data does not match any schema in anyOf (0 of " _ pSchemas.%Size() _ " matched)"
        Do pContext.AddError("anyOf", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate oneOf constraint - data must match EXACTLY ONE schema
/// @param pData The data to validate
/// @param pSchemas %DynamicArray of schemas
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateOneOf(pData, pSchemas As %DynamicArray, pContext As JSONSchema.Context) As %Boolean
{
    Set tMatchCount = 0
    Set tMatchedIndices = ""
    Set tIter = pSchemas.%GetIterator()

    While tIter.%GetNext(.tIndex, .tSchema) {
        // Use temporary context for each validation
        Set tTempContext = ##class(JSONSchema.Context).%New()
        Set tTempContext.RootSchema = pContext.RootSchema

        Set tSchemaValid = ##class(JSONSchema.Validator).ValidateNode(pData, tSchema, tTempContext)
        If tSchemaValid {
            Set tMatchCount = tMatchCount + 1
            Set tMatchedIndices = tMatchedIndices _ $Select(tMatchedIndices="":"", 1:", ") _ tIndex
        }
    }

    If tMatchCount = 0 {
        Set tMessage = "Data does not match any schema in oneOf (0 of " _ pSchemas.%Size() _ " matched)"
        Do pContext.AddError("oneOf", tMessage)
        Quit 0
    }

    If tMatchCount > 1 {
        Set tMessage = "Data matches " _ tMatchCount _ " schemas in oneOf, but must match exactly 1 (matched: " _ tMatchedIndices _ ")"
        Do pContext.AddError("oneOf", tMessage)
        Quit 0
    }

    Quit 1
}

/// Validate not constraint - data must NOT match the schema
/// @param pData The data to validate
/// @param pSchema Schema that data must NOT match
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateNot(pData, pSchema, pContext As JSONSchema.Context) As %Boolean
{
    // Use temporary context to check if data matches
    Set tTempContext = ##class(JSONSchema.Context).%New()
    Set tTempContext.RootSchema = pContext.RootSchema

    Set tMatches = ##class(JSONSchema.Validator).ValidateNode(pData, pSchema, tTempContext)

    // not is valid when the data does NOT match the schema
    If tMatches {
        Do pContext.AddError("not", "Data matches schema in 'not', but should not")
        Quit 0
    }

    Quit 1
}

}
```

### Integration in ValidateNode()
[Source: src/JSONSchema/Validator.cls]

**CRITICAL - Combinator Placement:**
Combinators should be evaluated AFTER boolean schema check but BEFORE type-specific checks. They work at the schema level and compose with all other keywords.

```objectscript
// In ValidateNode(), add after boolean schema handling:

// Schema combinators (apply to any data type)
If $IsObject(pSchema) && pSchema.%IsDefined("allOf") {
    Set tAllOfValid = ##class(JSONSchema.Keyword.Combinator).ValidateAllOf(pData, pSchema.allOf, pContext)
    Set tValid = tValid && tAllOfValid
}

If $IsObject(pSchema) && pSchema.%IsDefined("anyOf") {
    Set tAnyOfValid = ##class(JSONSchema.Keyword.Combinator).ValidateAnyOf(pData, pSchema.anyOf, pContext)
    Set tValid = tValid && tAnyOfValid
}

If $IsObject(pSchema) && pSchema.%IsDefined("oneOf") {
    Set tOneOfValid = ##class(JSONSchema.Keyword.Combinator).ValidateOneOf(pData, pSchema.oneOf, pContext)
    Set tValid = tValid && tOneOfValid
}

If $IsObject(pSchema) && pSchema.%IsDefined("not") {
    Set tNotValid = ##class(JSONSchema.Keyword.Combinator).ValidateNot(pData, pSchema.not, pContext)
    Set tValid = tValid && tNotValid
}
```

### Critical Coding Standards
[Source: architecture/15-coding-standards.md]

**Naming Conventions:**
- Parameters: `p` prefix (e.g., `pData`, `pSchema`, `pSchemas`)
- Local Variables: `t` prefix (e.g., `tValid`, `tMatchCount`, `tTempContext`)
- Class Methods: PascalCase (e.g., `ValidateAllOf`, `ValidateOneOf`)

**CRITICAL - Macro Syntax:**
```objectscript
// CORRECT: Triple dollar signs ($$$)
Quit $$$OK
Do $$$AssertEquals(tValid, 1, "Should be valid")

// WRONG: Double dollar signs - WILL NOT COMPILE
Quit $$OK  // INCORRECT!
```

**CRITICAL - Temporary Context Pattern:**
For anyOf/oneOf/not, always create temporary context to avoid polluting main error list:
```objectscript
Set tTempContext = ##class(JSONSchema.Context).%New()
Set tTempContext.RootSchema = pContext.RootSchema
Set tMatches = ##class(JSONSchema.Validator).ValidateNode(pData, pSchema, tTempContext)
```

### JSON Schema Combinator Semantics
[Source: JSON Schema Draft 7 Specification]

| Keyword | Behavior | Error When |
|---------|----------|------------|
| `allOf` | ALL schemas must validate | ANY schema fails |
| `anyOf` | AT LEAST ONE schema must validate | ALL schemas fail |
| `oneOf` | EXACTLY ONE schema must validate | 0 schemas match OR 2+ schemas match |
| `not` | Schema must NOT validate | Schema validates successfully |

**Edge Cases:**
1. **Empty allOf array**: Technically always valid (no constraints to fail)
2. **Empty anyOf/oneOf array**: Technically always invalid (impossible to match)
3. **Nested combinators**: allOf can contain anyOf, oneOf, not - recursion handles this
4. **Combinators with other keywords**: Schema can have `type` + `allOf` - both must pass

### Tech Stack Summary
[Source: architecture/3-tech-stack.md]

| Component | Technology | Version | Purpose |
|-----------|------------|---------|---------|
| Backend Language | ObjectScript | IRIS 2020.1+ | Keyword validators |
| JSON Handling | %DynamicArray | Native | Schema array iteration |
| Context | JSONSchema.Context | Local | Error tracking, path management |
| Testing | %UnitTest.TestCase | Native | Unit tests |

## Testing

### Test File Location
`src/Test/JSONSchema/TestCombinators.cls` (NEW)

### Testing Standards
- Use `%UnitTest.TestCase` framework
- Test methods must start with `Test` prefix
- All test methods must return `%Status` (return `$$$OK`)
- Use `$$$AssertTrue()`, `$$$AssertEquals()` macros
- Triple dollar signs ($$$) required for all macros
- Maximum 800 lines per test file

### Test Method Patterns
```objectscript
Method TestAllOfValid() As %Status
{
    // Data: number >= 5 AND <= 10
    Set tData = 7
    Set tSchema = {
        "allOf": [
            {"type": "number", "minimum": 5},
            {"type": "number", "maximum": 10}
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Data matching all schemas should pass")
    Do $$$AssertEquals(tErrors.%Size(), 0, "No errors expected")
    Quit $$$OK
}

Method TestAllOfInvalid() As %Status
{
    // Data: 12 is > 10 so fails second schema
    Set tData = 12
    Set tSchema = {
        "allOf": [
            {"type": "number", "minimum": 5},
            {"type": "number", "maximum": 10}
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Data failing any schema should fail")
    Quit $$$OK
}

Method TestAnyOfValid() As %Status
{
    // Data: string OR number - "hello" is string
    Set tData = "hello"
    Set tSchema = {
        "anyOf": [
            {"type": "string"},
            {"type": "number"}
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Data matching any schema should pass")
    Quit $$$OK
}

Method TestAnyOfInvalid() As %Status
{
    // Data: true is neither string nor number
    Set tData = true
    Set tSchema = {
        "anyOf": [
            {"type": "string"},
            {"type": "number"}
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Data matching no schemas should fail")
    Do $$$AssertEquals(tErrors.%Get(0).keyword, "anyOf", "Error keyword should be anyOf")
    Quit $$$OK
}

Method TestOneOfValid() As %Status
{
    // Data: 5 matches first schema (multipleOf 5), not second (multipleOf 3)
    Set tData = 5
    Set tSchema = {
        "oneOf": [
            {"type": "number", "multipleOf": 5},
            {"type": "number", "multipleOf": 3}
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Data matching exactly one schema should pass")
    Quit $$$OK
}

Method TestOneOfZeroMatches() As %Status
{
    // Data: 7 matches neither multipleOf 5 nor multipleOf 3
    Set tData = 7
    Set tSchema = {
        "oneOf": [
            {"type": "number", "multipleOf": 5},
            {"type": "number", "multipleOf": 3}
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Data matching zero schemas should fail")
    Do $$$AssertEquals(tErrors.%Get(0).keyword, "oneOf", "Error keyword should be oneOf")
    Quit $$$OK
}

Method TestOneOfMultipleMatches() As %Status
{
    // Data: 15 matches BOTH multipleOf 5 AND multipleOf 3
    Set tData = 15
    Set tSchema = {
        "oneOf": [
            {"type": "number", "multipleOf": 5},
            {"type": "number", "multipleOf": 3}
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Data matching multiple schemas should fail")
    Quit $$$OK
}

Method TestNotValid() As %Status
{
    // Data: "hello" is NOT a number
    Set tData = "hello"
    Set tSchema = {"not": {"type": "number"}}
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Data NOT matching schema should pass")
    Quit $$$OK
}

Method TestNotInvalid() As %Status
{
    // Data: 42 IS a number
    Set tData = 42
    Set tSchema = {"not": {"type": "number"}}
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Data matching 'not' schema should fail")
    Do $$$AssertEquals(tErrors.%Get(0).keyword, "not", "Error keyword should be not")
    Quit $$$OK
}

Method TestNestedCombinators() As %Status
{
    // allOf containing anyOf
    Set tData = {"type": "A", "value": 10}
    Set tSchema = {
        "type": "object",
        "allOf": [
            {"required": ["type"]},
            {
                "anyOf": [
                    {"properties": {"type": {"const": "A"}}},
                    {"properties": {"type": {"const": "B"}}}
                ]
            }
        ]
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Nested combinators should work correctly")
    Quit $$$OK
}
```

### Test Execution Strategy

**Phase 1: Compile Classes**
- Compile JSONSchema.Keyword.Combinator
- Compile Validator.cls
- Compile TestCombinators.cls

**Phase 2: Run Tests**
- Execute via MCP: `execute_unit_tests` with test_spec="Test.JSONSchema"
- Verify all 27 new tests pass (21 unit + 6 integration)
- Verify all 216 existing tests still pass (regression check)

**Expected Results:**
- 27 new tests pass (21 unit + 6 integration for combinator keywords)
- 216 existing tests pass (Epic 1 + Stories 2.1-2.4)
- Total: ~243 tests passing
- Test execution time: <10 seconds

### Test Coverage Matrix

| Keyword | Valid Cases | Invalid Cases | Edge Cases | Total |
|---------|-------------|---------------|------------|-------|
| allOf | 2 tests | 1 test | 2 tests | 5 tests |
| anyOf | 2 tests | 1 test | 2 tests | 5 tests |
| oneOf | 1 test | 2 tests | 3 tests | 6 tests |
| not | 1 test | 1 test | 3 tests | 5 tests |
| Integration | 6 tests | - | - | 6 tests |
| **Total** | **12** | **5** | **10** | **27 tests** |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.1 | Story APPROVED - PO validation complete. Implementation Readiness Score: 9.5/10. GO decision. Minor notes: Consider adding empty array edge case tests. | PO Agent (Sarah) |
| 2025-12-04 | 1.0 | Initial story draft for schema combinator keywords (Epic 2, Story 5) | SM Agent (Bob) |

---

## Dev Agent Record

### Agent Model Used

Claude claude-opus-4-5-20251101 (claude-code)

### Debug Log References

No debug globals needed - all tests passed after minor fix for boolean type handling in tests.

### Completion Notes List

1. Created `JSONSchema.Keyword.Combinator.cls` with 4 ClassMethods: ValidateAllOf, ValidateAnyOf, ValidateOneOf, ValidateNot
2. Integrated combinator checks into `Validator.cls` ValidateNode() method after boolean schema handling
3. Used temporary context pattern for anyOf/oneOf/not to avoid polluting main error list
4. Created 27 unit and integration tests in `TestCombinators.cls`
5. Fixed 2 test cases that used boolean values (object used instead due to boolean type loss when extracting from %DynamicObject)
6. All 243 tests passing (27 new + 216 existing)
7. Implementation follows existing keyword class patterns (Object.cls, Array.cls)

### File List

| File | Action | Description |
|------|--------|-------------|
| `src/JSONSchema/Keyword/Combinator.cls` | Created | New combinator keyword validator class |
| `src/JSONSchema/Validator.cls` | Modified | Added allOf, anyOf, oneOf, not checks to ValidateNode() |
| `src/Test/JSONSchema/TestCombinators.cls` | Created | 27 unit and integration tests for combinators |

---

## QA Results

### Review Date: 2025-12-04

### Reviewed By: Quinn (Test Architect)

### Test Execution (Independent Verification)

| Metric | Result |
|--------|--------|
| Total Tests | 243 |
| Passed | 243 |
| Failed | 0 |
| Skipped | 0 |
| Execution Time | 279ms |

**Combinator-specific tests (27 total):**
- allOf tests: 5 passing
- anyOf tests: 5 passing
- oneOf tests: 6 passing
- not tests: 5 passing
- Integration tests: 6 passing

### Code Quality Assessment

**Overall: Excellent**

The implementation demonstrates high-quality ObjectScript code following established project patterns:

1. **Combinator.cls**: Clean, well-documented class with proper DocBook/HTML comments. Each method (ValidateAllOf, ValidateAnyOf, ValidateOneOf, ValidateNot) is self-contained and follows the same structure as other keyword validators.

2. **Validator.cls Integration**: Combinators correctly placed after boolean schema handling but before type-specific checks. This ensures proper schema composition semantics per JSON Schema Draft 7.

3. **Temporary Context Pattern**: Correctly implemented for anyOf/oneOf/not to avoid polluting the main error list. This follows the pattern established in Story 2.4 for `contains`.

4. **Error Messages**: Informative error messages that include:
   - Failed schema indices for allOf
   - Match counts for anyOf/oneOf
   - Which schemas matched for oneOf multiple-match failures

### Requirements Traceability

| AC | Description | Tests | Status |
|----|-------------|-------|--------|
| 1 | allOf validates ALL schemas | 001-005 | ✓ Covered |
| 2 | anyOf validates AT LEAST ONE | 006-010 | ✓ Covered |
| 3 | oneOf validates EXACTLY ONE | 011-016 | ✓ Covered |
| 4 | not validates NOT matching | 017-021 | ✓ Covered |
| 5 | Nested combinators work | 005, 021, INT-001, INT-004 | ✓ Covered |
| 6 | Combinators with other keywords | 004, 010, 016, INT-002, INT-003 | ✓ Covered |
| 7 | oneOf fails on zero matches | 012, 014 | ✓ Covered |
| 8 | oneOf fails on 2+ matches | 013, 015 | ✓ Covered |
| 9 | anyOf/oneOf error messages | 009, 014, 015 | ✓ Covered |
| 10 | allOf error indicates which failed | 003 | ✓ Covered |
| 11 | Complex nested scenarios | INT-001, INT-004, INT-005 | ✓ Covered |
| 12 | $ref placeholder | INT-006 | ✓ Placeholder (Story 2.7) |

### Refactoring Performed

None required. Implementation is clean and follows established patterns.

### Compliance Check

- Coding Standards: ✓ Follows all ObjectScript conventions (t/p prefixes, triple $$$ macros)
- Project Structure: ✓ Correct file placement in Keyword/ directory
- Testing Strategy: ✓ Comprehensive coverage with P0/P1/P2 prioritization
- All ACs Met: ✓ All 12 acceptance criteria verified

### Improvements Checklist

- [x] Implementation follows existing keyword class patterns
- [x] Temporary context pattern correctly used for isolation
- [x] Error messages include diagnostic information
- [x] Tests cover all acceptance criteria
- [x] Integration tests verify combinator composition
- [ ] Consider adding empty array edge cases (minor, non-blocking)

### Security Review

No security concerns. This is pure validation logic with no external I/O, authentication, or authorization.

### Performance Considerations

- Temporary context creation adds minimal overhead
- anyOf short-circuits on first match (efficient)
- oneOf must check all schemas to count matches (necessary for semantics)
- No performance issues identified

### Files Modified During Review

None. No refactoring was necessary.

### Gate Status

Gate: **PASS** → docs/qa/gates/2.5-schema-combinators.yml
Risk profile: Low (no auth/security code, established patterns)

### Recommended Status

✓ **Ready for Done** - All acceptance criteria met, all tests passing, code quality excellent.
