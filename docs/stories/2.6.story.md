# Story 2.6: Conditional Schema Keywords

## Status

**Done**

## Story

**As a** developer,
**I want** the validator to support if/then/else conditional validation and dependencies,
**so that** I can create schemas with conditional requirements.

## Acceptance Criteria

1. `if` schema evaluated first - if passes, `then` is applied; if fails, `else` is applied
2. `if/then` without `else` - validation passes if `if` fails (no `else` constraint)
3. `if/else` without `then` - validation passes if `if` succeeds (no `then` constraint)
4. `then` and `else` can be any valid schema (including combinators, refs)
5. Multiple `if/then/else` can be combined using `allOf`
6. Conditional schemas work with object property validation
7. Error messages indicate which branch (then/else) failed
8. `dependencies` keyword validates property dependencies (Draft 7 style)
9. Property dependencies: if property A exists, properties B and C must exist
10. Schema dependencies: if property A exists, additional schema must validate
11. Unit tests cover common conditional patterns (required-if, type-switching)
12. Unit tests cover nested conditionals

## Tasks / Subtasks

- [x] **Task 1: Create JSONSchema.Keyword.Conditional.cls** (AC: 1, 2, 3, 4, 7)
  - [x] Create file: `src/JSONSchema/Keyword/Conditional.cls`
  - [x] Add class header and documentation following existing pattern (see Combinator.cls)
  - [x] Implement `ValidateIfThenElse(pData, pSchema, pContext)` ClassMethod
    - [x] Check if `if` schema is defined in pSchema
    - [x] Use temporary context to evaluate `if` schema (avoid polluting errors)
    - [x] If `if` passes AND `then` exists, validate data against `then` schema
    - [x] If `if` fails AND `else` exists, validate data against `else` schema
    - [x] If `if` passes and no `then`, validation passes (no constraint)
    - [x] If `if` fails and no `else`, validation passes (no constraint)
    - [x] Report errors from `then`/`else` validation with clear branch indication
  - [x] Compile using MCP tool `compile_objectscript_class`

- [x] **Task 2: Create Dependencies Validation Methods** (AC: 8, 9, 10)
  - [x] Implement `ValidateDependencies(pData, pDependencies, pContext)` ClassMethod
    - [x] Iterate through each key in dependencies object
    - [x] Check if key property exists in data
    - [x] If dependency value is array (property dependencies): validate required props exist
    - [x] If dependency value is object (schema dependencies): validate data against schema
  - [x] Implement `ValidatePropertyDependency(pData, pPropertyName, pRequiredProps, pContext)` ClassMethod
    - [x] If pPropertyName exists in pData, check all pRequiredProps exist
    - [x] Add error if any required property is missing
  - [x] Implement `ValidateSchemaDependency(pData, pPropertyName, pSchema, pContext)` ClassMethod
    - [x] If pPropertyName exists in pData, validate entire data against pSchema
    - [x] Use standard ValidateNode for schema validation
  - [x] Compile using MCP tool `compile_objectscript_class`

- [x] **Task 3: Integrate Conditionals into ValidateNode() and ValidateNodeWithType()** (AC: 1, 5, 6, 8)
  - [x] Add conditional checks in ValidateNode() (AFTER combinator checks, BEFORE type-specific)
  - [x] Conditional validation pattern:
    - [x] Check `pSchema.%IsDefined("if")` -> Call Conditional.ValidateIfThenElse()
    - [x] Check `pSchema.%IsDefined("dependencies")` -> Call Conditional.ValidateDependencies()
  - [x] Add same conditional checks in ValidateNodeWithType() (for array item validation)
    - [x] Add if/then/else check after boolean schema handling
    - [x] Add dependencies check (only for object data)
  - [x] Ensure conditionals compose with other keywords (type, properties, combinators)
  - [x] Compile Validator.cls using MCP tool

- [x] **Task 4: Create Unit Tests for if/then/else** (AC: 1, 2, 3, 4, 7)
  - [x] Create test file: `src/Test/JSONSchema/TestConditional.cls`
  - [x] **2.6-UNIT-001 (P0)**: `TestIfThenValid()` - if passes, then applies, data valid
  - [x] **2.6-UNIT-002 (P0)**: `TestIfThenInvalid()` - if passes, then applies, data invalid
  - [x] **2.6-UNIT-003 (P0)**: `TestIfElseValid()` - if fails, else applies, data valid
  - [x] **2.6-UNIT-004 (P0)**: `TestIfElseInvalid()` - if fails, else applies, data invalid
  - [x] **2.6-UNIT-005 (P1)**: `TestIfThenNoElse()` - if fails, no else, passes
  - [x] **2.6-UNIT-006 (P1)**: `TestIfElseNoThen()` - if passes, no then, passes
  - [x] **2.6-UNIT-007 (P1)**: `TestIfThenElseErrorMessage()` - error indicates branch
  - [x] **2.6-UNIT-008 (P1)**: `TestIfWithCombinators()` - then/else use allOf/anyOf

- [x] **Task 5: Create Unit Tests for dependencies** (AC: 8, 9, 10)
  - [x] **2.6-UNIT-009 (P0)**: `TestPropertyDependencyValid()` - required props exist
  - [x] **2.6-UNIT-010 (P0)**: `TestPropertyDependencyInvalid()` - required prop missing
  - [x] **2.6-UNIT-011 (P0)**: `TestPropertyDependencyNotTriggered()` - trigger prop absent
  - [x] **2.6-UNIT-012 (P0)**: `TestSchemaDependencyValid()` - schema validates
  - [x] **2.6-UNIT-013 (P0)**: `TestSchemaDependencyInvalid()` - schema fails
  - [x] **2.6-UNIT-014 (P1)**: `TestSchemaDependencyNotTriggered()` - trigger prop absent
  - [x] **2.6-UNIT-015 (P1)**: `TestMultipleDependencies()` - multiple dependency keys
  - [x] **2.6-UNIT-016 (P1)**: `TestDependencyErrorMessage()` - error indicates missing prop

- [x] **Task 6: Create Integration Tests** (AC: 5, 6, 11, 12)
  - [x] **2.6-INT-001 (P1)**: `TestConditionalWithProperties()` - if/then with object properties
  - [x] **2.6-INT-002 (P1)**: `TestConditionalTypeSwitching()` - type changes based on property value
  - [x] **2.6-INT-003 (P1)**: `TestMultipleIfThenElseAllOf()` - allOf combining multiple conditionals
  - [x] **2.6-INT-004 (P1)**: `TestNestedConditional()` - then schema contains another if/then
  - [x] **2.6-INT-005 (P1)**: `TestConditionalWithCombinators()` - if/then inside anyOf
  - [x] **2.6-INT-006 (P2)**: `TestDependenciesWithConditional()` - dependencies + if/then combined
  - [x] **2.6-INT-007 (P2)**: `TestConditionalErrorPaths()` - error paths through conditionals

- [x] **Task 7: Compile and Run All Tests** (AC: 11, 12)
  - [x] Compile JSONSchema.Keyword.Conditional using MCP tool
  - [x] Compile Validator.cls using MCP tool
  - [x] Compile TestConditional.cls using MCP tool
  - [x] Run all tests using MCP tool `execute_unit_tests` with test_spec="Test.JSONSchema"
  - [x] Verify all new tests pass (23 new tests: 16 unit + 7 integration)
  - [x] Verify all existing tests still pass (~243 tests from Epic 1 + Stories 2.1-2.5)
  - [x] Total expected: ~266 tests passing

## Dev Notes

### Previous Story Insights
[Source: docs/stories/2.5.story.md - Dev Agent Record]

**Key learnings from Story 2.5 (Schema Combinators):**
1. **Temporary Context Pattern**: For if/then/else evaluation, create temporary context to avoid polluting errors - CRITICAL for evaluating `if` schema silently
2. **Boolean Type Loss Issue**: When extracting values from `%DynamicArray`, booleans become integers (true->1). Use `%GetTypeOf()` before extraction
3. **Validation Return Pattern**: Use `Set tFound = 1` flag pattern then check after loop
4. **All 243 tests currently passing** - do not break existing tests
5. **Combinator placement**: Combinators placed AFTER boolean schema check, BEFORE type-specific checks - conditionals should follow same pattern

### Project Structure
[Source: architecture/10-project-structure.md]

**Current Structure:**
```
src/JSONSchema/
├── Validator.cls
├── Context.cls
└── Keyword/
    ├── Type.cls       # Existing
    ├── Enum.cls       # Existing
    ├── Const.cls      # Existing
    ├── String.cls     # Existing (Story 2.1)
    ├── Numeric.cls    # Existing (Story 2.2)
    ├── Object.cls     # Existing (Story 2.3)
    ├── Array.cls      # Existing (Story 2.4)
    ├── Combinator.cls # Existing (Story 2.5)
    └── Conditional.cls # NEW - Story 2.6
```

**Test Structure:**
```
src/Test/JSONSchema/
├── TestValidator.cls         # Foundation tests
├── TestTypeValidation.cls    # Type keyword tests
├── TestEnumConst.cls         # Enum/Const tests
├── TestInputFormats.cls      # Input format tests
├── TestStringKeywords.cls    # String keyword tests (Story 2.1)
├── TestNumericKeywords.cls   # Numeric keyword tests (Story 2.2)
├── TestObjectKeywords.cls    # Object keyword tests (Story 2.3)
├── TestArrayKeywords.cls     # Array keyword tests (Story 2.4)
├── TestCombinators.cls       # Combinator tests (Story 2.5)
├── TestContext.cls           # Existing
├── TestPathTracking.cls      # Existing
└── TestConditional.cls       # NEW - Story 2.6
```

### Conditional Implementation Pattern
[Source: architecture/9-backend-architecture.md, JSON Schema Draft 7 Specification]

**Keyword Class Template:**
```objectscript
/// JSONSchema.Keyword.Conditional - Conditional schema validators
/// <p>
/// Validates JSON Schema conditional keywords: if/then/else, dependencies
/// </p>
Class JSONSchema.Keyword.Conditional Extends %RegisteredObject
{

/// Validate if/then/else conditional schema
/// @param pData The data to validate
/// @param pSchema The full schema containing if/then/else
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateIfThenElse(pData, pSchema, pContext As JSONSchema.Context) As %Boolean
{
    Set tValid = 1

    // Get the if schema
    Set tIfSchema = pSchema.if

    // Evaluate if schema using temporary context (silent evaluation)
    Set tTempContext = ##class(JSONSchema.Context).%New()
    Set tTempContext.RootSchema = pContext.RootSchema

    Set tIfPasses = ##class(JSONSchema.Validator).ValidateNode(pData, tIfSchema, tTempContext)

    If tIfPasses {
        // if passed - apply then schema if exists
        If pSchema.%IsDefined("then") {
            Set tThenSchema = pSchema.then
            Set tThenValid = ##class(JSONSchema.Validator).ValidateNode(pData, tThenSchema, pContext)
            If 'tThenValid {
                Do pContext.AddError("then", "Data fails 'then' schema after passing 'if' condition")
                Set tValid = 0
            }
        }
        // No then schema - passes by default
    }
    Else {
        // if failed - apply else schema if exists
        If pSchema.%IsDefined("else") {
            Set tElseSchema = pSchema.else
            Set tElseValid = ##class(JSONSchema.Validator).ValidateNode(pData, tElseSchema, pContext)
            If 'tElseValid {
                Do pContext.AddError("else", "Data fails 'else' schema after failing 'if' condition")
                Set tValid = 0
            }
        }
        // No else schema - passes by default
    }

    Quit tValid
}

/// Validate dependencies constraint
/// @param pData The object data to validate
/// @param pDependencies Object mapping property names to dependencies
/// @param pContext Validation context for error reporting
/// @return 1 if valid, 0 if invalid
ClassMethod ValidateDependencies(pData, pDependencies, pContext As JSONSchema.Context) As %Boolean
{
    Set tValid = 1
    Set tIter = pDependencies.%GetIterator()

    While tIter.%GetNext(.tPropName, .tDependency) {
        // Only check if trigger property exists in data
        If 'pData.%IsDefined(tPropName) {
            Continue
        }

        // Check dependency type
        If $IsObject(tDependency) && tDependency.%IsA("%Library.DynamicArray") {
            // Property dependency - array of required property names
            Set tPropValid = ..ValidatePropertyDependency(pData, tPropName, tDependency, pContext)
            Set tValid = tValid && tPropValid
        }
        ElseIf $IsObject(tDependency) {
            // Schema dependency - schema that must validate
            Set tSchemaValid = ..ValidateSchemaDependency(pData, tPropName, tDependency, pContext)
            Set tValid = tValid && tSchemaValid
        }
    }

    Quit tValid
}

/// Validate property dependency (array of required properties)
ClassMethod ValidatePropertyDependency(pData, pPropertyName As %String, pRequiredProps As %DynamicArray, pContext As JSONSchema.Context) As %Boolean
{
    Set tValid = 1
    Set tIter = pRequiredProps.%GetIterator()

    While tIter.%GetNext(.tIdx, .tRequiredProp) {
        If 'pData.%IsDefined(tRequiredProp) {
            Set tMessage = "Property '" _ pPropertyName _ "' requires property '" _ tRequiredProp _ "' to be present"
            Do pContext.AddError("dependencies", tMessage)
            Set tValid = 0
        }
    }

    Quit tValid
}

/// Validate schema dependency (schema that must validate when property exists)
ClassMethod ValidateSchemaDependency(pData, pPropertyName As %String, pSchema, pContext As JSONSchema.Context) As %Boolean
{
    // Validate entire data against the dependency schema
    Set tValid = ##class(JSONSchema.Validator).ValidateNode(pData, pSchema, pContext)

    If 'tValid {
        Set tMessage = "Property '" _ pPropertyName _ "' dependency schema failed"
        Do pContext.AddError("dependencies", tMessage)
    }

    Quit tValid
}

}
```

### Integration in ValidateNode() and ValidateNodeWithType()
[Source: src/JSONSchema/Validator.cls]

**CRITICAL - Conditional Placement:**
Conditionals should be evaluated AFTER combinator checks but BEFORE type-specific checks. They work at the schema level and compose with all other keywords.

**IMPORTANT:** Both `ValidateNode()` AND `ValidateNodeWithType()` must include conditional checks. `ValidateNodeWithType()` is used for array item validation and currently lacks combinator support - conditionals must be added to both methods for complete coverage.

```objectscript
// In ValidateNode(), add after combinator checks (around line 196):

// Conditional schemas (if/then/else)
If $IsObject(pSchema) && pSchema.%IsDefined("if") {
    Set tIfThenElseValid = ##class(JSONSchema.Keyword.Conditional).ValidateIfThenElse(pData, pSchema, pContext)
    Set tValid = tValid && tIfThenElseValid
}

// Dependencies (property and schema dependencies)
If $IsObject(pSchema) && pSchema.%IsDefined("dependencies") {
    // Only apply to object data
    If $IsObject(pData) && pData.%IsA("%Library.DynamicObject") {
        Set tDepsValid = ##class(JSONSchema.Keyword.Conditional).ValidateDependencies(pData, pSchema.dependencies, pContext)
        Set tValid = tValid && tDepsValid
    }
}
```

```objectscript
// In ValidateNodeWithType(), add after boolean schema handling (around line 600):

// Conditional schemas (if/then/else) - same as ValidateNode
If $IsObject(pSchema) && pSchema.%IsDefined("if") {
    Set tIfThenElseValid = ##class(JSONSchema.Keyword.Conditional).ValidateIfThenElse(pData, pSchema, pContext)
    Set tValid = tValid && tIfThenElseValid
}

// Dependencies (property and schema dependencies) - same as ValidateNode
If $IsObject(pSchema) && pSchema.%IsDefined("dependencies") {
    If $IsObject(pData) && pData.%IsA("%Library.DynamicObject") {
        Set tDepsValid = ##class(JSONSchema.Keyword.Conditional).ValidateDependencies(pData, pSchema.dependencies, pContext)
        Set tValid = tValid && tDepsValid
    }
}
```

### Critical Coding Standards
[Source: architecture/15-coding-standards.md]

**Naming Conventions:**
- Parameters: `p` prefix (e.g., `pData`, `pSchema`, `pDependencies`)
- Local Variables: `t` prefix (e.g., `tValid`, `tIfPasses`, `tTempContext`)
- Class Methods: PascalCase (e.g., `ValidateIfThenElse`, `ValidateDependencies`)

**CRITICAL - Macro Syntax:**
```objectscript
// CORRECT: Triple dollar signs ($$$)
Quit $$$OK
Do $$$AssertEquals(tValid, 1, "Should be valid")

// WRONG: Double dollar signs - WILL NOT COMPILE
Quit $$OK  // INCORRECT!
```

**CRITICAL - Temporary Context Pattern:**
For if/then/else evaluation, always create temporary context to evaluate `if` silently:
```objectscript
Set tTempContext = ##class(JSONSchema.Context).%New()
Set tTempContext.RootSchema = pContext.RootSchema
Set tIfPasses = ##class(JSONSchema.Validator).ValidateNode(pData, tIfSchema, tTempContext)
```

### JSON Schema Conditional Semantics
[Source: JSON Schema Draft 7 Specification]

| Keyword | Behavior | Notes |
|---------|----------|-------|
| `if` | Schema to evaluate conditionally | Evaluated silently (errors not collected) |
| `then` | Applied if `if` passes | Only evaluated when `if` validates |
| `else` | Applied if `if` fails | Only evaluated when `if` does NOT validate |
| `dependencies` | Property-based constraints | Draft 7 style (later split in 2019-09) |

**if/then/else Truth Table:**
| if result | then exists | else exists | then result | else result | overall |
|-----------|-------------|-------------|-------------|-------------|---------|
| pass | yes | - | pass | - | pass |
| pass | yes | - | fail | - | fail |
| pass | no | - | - | - | pass |
| fail | - | yes | - | pass | pass |
| fail | - | yes | - | fail | fail |
| fail | - | no | - | - | pass |

**Dependencies Types:**
1. **Property Dependencies (array)**: `{"a": ["b", "c"]}` - if "a" exists, "b" and "c" must exist
2. **Schema Dependencies (object)**: `{"a": {"required": ["b"]}}` - if "a" exists, data must match schema

**Edge Cases:**
1. **if without then or else**: Always valid (no constraints applied)
2. **then/else without if**: Ignored (keywords only meaningful with if)
3. **Nested conditionals**: then/else can contain another if/then/else
4. **Conditionals with combinators**: Can be nested inside allOf, anyOf, oneOf

### Tech Stack Summary
[Source: architecture/3-tech-stack.md]

| Component | Technology | Version | Purpose |
|-----------|------------|---------|---------|
| Backend Language | ObjectScript | IRIS 2020.1+ | Keyword validators |
| JSON Handling | %DynamicObject | Native | Schema/data iteration |
| Context | JSONSchema.Context | Local | Error tracking, path management |
| Testing | %UnitTest.TestCase | Native | Unit tests |

## Testing

### Test File Location
`src/Test/JSONSchema/TestConditional.cls` (NEW)

### Testing Standards
- Use `%UnitTest.TestCase` framework
- Test methods must start with `Test` prefix
- All test methods must return `%Status` (return `$$$OK`)
- Use `$$$AssertTrue()`, `$$$AssertEquals()` macros
- Triple dollar signs ($$$) required for all macros
- Maximum 800 lines per test file

### Test Method Patterns
```objectscript
Method TestIfThenValid() As %Status
{
    // if property type=string, then minLength=3
    Set tData = {"type": "string", "value": "hello"}
    Set tSchema = {
        "type": "object",
        "if": {"properties": {"type": {"const": "string"}}},
        "then": {"properties": {"value": {"minLength": 3}}}
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Data matching then schema should pass")
    Do $$$AssertEquals(tErrors.%Size(), 0, "No errors expected")
    Quit $$$OK
}

Method TestIfThenInvalid() As %Status
{
    // if property type=string, then minLength=3, but value is "ab" (too short)
    Set tData = {"type": "string", "value": "ab"}
    Set tSchema = {
        "type": "object",
        "if": {"properties": {"type": {"const": "string"}}},
        "then": {"properties": {"value": {"minLength": 3}}}
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Data failing then schema should fail")
    Quit $$$OK
}

Method TestIfElseValid() As %Status
{
    // if type=string fails (type is number), else requires minimum
    Set tData = {"type": "number", "value": 10}
    Set tSchema = {
        "type": "object",
        "if": {"properties": {"type": {"const": "string"}}},
        "then": {"properties": {"value": {"minLength": 3}}},
        "else": {"properties": {"value": {"minimum": 0}}}
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Data matching else schema should pass")
    Quit $$$OK
}

Method TestPropertyDependencyValid() As %Status
{
    // If "credit_card" exists, "billing_address" must exist
    Set tData = {"credit_card": "1234", "billing_address": "123 Main St"}
    Set tSchema = {
        "type": "object",
        "dependencies": {
            "credit_card": ["billing_address"]
        }
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Property dependency satisfied should pass")
    Quit $$$OK
}

Method TestPropertyDependencyInvalid() As %Status
{
    // If "credit_card" exists, "billing_address" must exist (but doesn't)
    Set tData = {"credit_card": "1234"}
    Set tSchema = {
        "type": "object",
        "dependencies": {
            "credit_card": ["billing_address"]
        }
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 0, "Missing required dependency should fail")
    Do $$$AssertEquals(tErrors.%Get(0).keyword, "dependencies", "Error keyword should be dependencies")
    Quit $$$OK
}

Method TestSchemaDependencyValid() As %Status
{
    // If "name" exists, object must have "age" property (via schema)
    Set tData = {"name": "John", "age": 30}
    Set tSchema = {
        "type": "object",
        "dependencies": {
            "name": {"required": ["age"]}
        }
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Schema dependency satisfied should pass")
    Quit $$$OK
}

Method TestNestedConditional() As %Status
{
    // then contains another if/then
    Set tData = {"type": "premium", "level": "gold", "discount": 20}
    Set tSchema = {
        "type": "object",
        "if": {"properties": {"type": {"const": "premium"}}},
        "then": {
            "if": {"properties": {"level": {"const": "gold"}}},
            "then": {"properties": {"discount": {"minimum": 15}}}
        }
    }
    Set tValid = ##class(JSONSchema.Validator).Validate(tData, tSchema, .tErrors)
    Do $$$AssertEquals(tValid, 1, "Nested conditional should validate correctly")
    Quit $$$OK
}
```

### Test Execution Strategy

**Phase 1: Compile Classes**
- Compile JSONSchema.Keyword.Conditional
- Compile Validator.cls
- Compile TestConditional.cls

**Phase 2: Run Tests**
- Execute via MCP: `execute_unit_tests` with test_spec="Test.JSONSchema"
- Verify all 23 new tests pass (16 unit + 7 integration)
- Verify all 243 existing tests still pass (regression check)

**Expected Results:**
- 23 new tests pass (16 unit + 7 integration for conditional keywords)
- 243 existing tests pass (Epic 1 + Stories 2.1-2.5)
- Total: ~266 tests passing
- Test execution time: <10 seconds

### Test Coverage Matrix

| Keyword | Unit Tests | Integration | Total |
|---------|------------|-------------|-------|
| if/then/else | 8 tests (UNIT-001 to UNIT-008) | - | 8 tests |
| dependencies | 8 tests (UNIT-009 to UNIT-016) | - | 8 tests |
| Integration | - | 7 tests (INT-001 to INT-007) | 7 tests |
| **Total** | **16 unit** | **7 integration** | **23 tests** |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.2 | Updated: Fixed test count matrix (23 tests), added ValidateNodeWithType integration guidance to Task 3 and Dev Notes | PO Agent (Sarah) |
| 2025-12-04 | 1.1 | Story APPROVED - PO validation complete. Implementation Readiness Score: 9.5/10. GO decision. | PO Agent (Sarah) |
| 2025-12-04 | 1.0 | Initial story draft for conditional schema keywords (Epic 2, Story 6) | SM Agent (Bob) |

---

## Dev Agent Record

### Agent Model Used

Claude claude-opus-4-5-20251101 (Anthropic)

### Debug Log References

N/A - Implementation completed without debugging issues.

### Completion Notes List

1. Created `JSONSchema.Keyword.Conditional.cls` with `ValidateIfThenElse()`, `ValidateDependencies()`, `ValidatePropertyDependency()`, and `ValidateSchemaDependency()` methods
2. Integrated conditional checks into both `ValidateNode()` and `ValidateNodeWithType()` in Validator.cls
3. Added combinator support (allOf, anyOf, oneOf, not) to `ValidateNodeWithType()` which was previously missing
4. Created comprehensive test file `TestConditional.cls` with 23 tests (16 unit + 7 integration)
5. Fixed `TestConditionalWithCombinators` test - changed from `oneOf` to `anyOf` because with if/then/else semantics, schemas without else pass when if fails, causing multiple oneOf matches
6. All 266 tests passing (23 new + 243 existing)

### File List

| File | Action | Description |
|------|--------|-------------|
| `src/JSONSchema/Keyword/Conditional.cls` | Created | New keyword handler for if/then/else and dependencies |
| `src/JSONSchema/Validator.cls` | Modified | Added conditional and combinator support to both ValidateNode() and ValidateNodeWithType() |
| `src/Test/JSONSchema/TestConditional.cls` | Created | 23 tests for conditional schema keywords |

---

## QA Results

### Review Date: 2025-12-04

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: EXCELLENT** - Implementation demonstrates high-quality code adhering to project standards.

**Strengths:**
- Well-documented with DocBook markup in all classes
- Follows project coding standards (p/t prefixes, `$$$OK` patterns, proper indentation)
- Proper temporary context pattern for silent `if` schema evaluation
- Clean separation of concerns with dedicated `Conditional.cls` keyword handler
- Both `ValidateNode()` AND `ValidateNodeWithType()` updated for complete coverage
- **Bonus**: Added missing combinator support to `ValidateNodeWithType()` (addressed pre-existing gap)

### Refactoring Performed

None required - implementation is clean and well-structured.

### Compliance Check

- Coding Standards: ✓ All naming conventions followed (p/t prefixes, PascalCase methods)
- Project Structure: ✓ New files in correct locations per architecture docs
- Testing Strategy: ✓ 23 tests with unit + integration coverage
- All ACs Met: ✓ All 12 acceptance criteria fully implemented and tested

### Requirements Traceability

| AC | Requirement | Validating Tests |
|----|-------------|-----------------|
| 1 | if schema evaluated first | TestIfThenValid, TestIfElseValid |
| 2 | if/then without else passes when if fails | TestIfThenNoElse |
| 3 | if/else without then passes when if succeeds | TestIfElseNoThen |
| 4 | then/else can be any valid schema | TestIfWithCombinators |
| 5 | Multiple if/then/else via allOf | TestMultipleIfThenElseAllOf |
| 6 | Conditionals work with object properties | TestConditionalWithProperties |
| 7 | Error messages indicate branch | TestIfThenElseErrorMessage |
| 8 | dependencies keyword validates | TestPropertyDependencyValid/Invalid |
| 9 | Property dependencies (A requires B,C) | TestPropertyDependency* (3 tests) |
| 10 | Schema dependencies | TestSchemaDependency* (3 tests) |
| 11 | Common conditional patterns | All unit tests |
| 12 | Nested conditionals | TestNestedConditional |

**Coverage Gaps: NONE** - All acceptance criteria have corresponding test coverage.

### Improvements Checklist

All items complete - no changes required:

- [x] Conditional.cls implements if/then/else with temporary context pattern
- [x] Conditional.cls implements property and schema dependencies
- [x] ValidateNode() includes conditional and dependency checks
- [x] ValidateNodeWithType() includes conditional and dependency checks
- [x] 23 tests covering all acceptance criteria
- [x] Error messages indicate which branch (then/else) failed
- [x] DocBook documentation complete

### Security Review

No security concerns - this is pure validation logic with no external interactions, authentication, or data persistence.

### Performance Considerations

No performance concerns identified:
- Temporary context creation is lightweight
- No additional loops or expensive operations beyond standard schema traversal

### Files Modified During Review

None - no refactoring was necessary.

### Gate Status

Gate: **PASS** → docs/qa/gates/2.6-conditional-schema-keywords.yml

### Test Execution Summary

| Metric | Value |
|--------|-------|
| Timestamp | 2025-12-04T15:28:43-08:00 |
| Total Tests | 266 |
| Passed | 266 |
| Failed | 0 |
| New Tests (Story 2.6) | 23 |
| Execution Time | 271ms |

### Recommended Status

✓ **Ready for Done** - All acceptance criteria met, comprehensive test coverage, high code quality.
